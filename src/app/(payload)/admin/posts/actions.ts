'use server'

import { getPayload } from 'payload'
import config from '@payload-config'

export async function duplicatePosts(postIds: number[]) {
  const payload = await getPayload({ config })
  const results: { id: number; title: string }[] = []
  const errors: { id: number; error: string }[] = []

  for (const id of postIds) {
    try {
      const original = await payload.findByID({
        collection: 'posts',
        id,
        depth: 0, // Don't populate relationships, just get IDs
      })

      // Build duplicate data, preserving relationships but resetting status fields
      const duplicateData = {
        title: `${original.title} (CÃ³pia)`,
        content: original.content,
        excerpt: original.excerpt,
        // Relationships - keep the IDs
        author: typeof original.author === 'object' ? original.author?.id : original.author,
        categories: original.categories?.map((c: any) => typeof c === 'object' ? c.id : c),
        tags: original.tags?.map((t: any) => typeof t === 'object' ? t.id : t),
        featuredImage: typeof original.featuredImage === 'object' ? original.featuredImage?.id : original.featuredImage,
        // WordPress legacy fields
        wpFeaturedImage: original.wpFeaturedImage,
        wpDatabaseId: undefined, // Don't copy WP ID
        // Custom fields
        antetitulo: original.antetitulo,
        chamadaDestaque: original.chamadaDestaque,
        chamadaManchete: original.chamadaManchete,
        // Reset these for draft
        _status: 'draft' as const,
        publishedOnce: false,
        publishedAt: new Date().toISOString(),
        // These will be auto-generated by hooks:
        // slug: undefined (will be generated from title)
        // uri: undefined (will be generated from publishedAt + slug)
      }

      const created = await payload.create({
        collection: 'posts',
        data: duplicateData,
        draft: true,
      })

      results.push({ id: created.id as number, title: created.title as string })
    } catch (error: any) {
      errors.push({ id, error: error.message })
    }
  }

  return {
    success: errors.length === 0,
    duplicated: results,
    errors,
    message: errors.length === 0
      ? `${results.length} artigo(s) duplicado(s) com sucesso`
      : `${results.length} duplicado(s), ${errors.length} erro(s)`,
  }
}
